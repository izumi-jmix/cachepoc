### Использовались:
* Jmix v. 1.5.5
* JDK - Liberica 11.0.14
* DB - Postgres 15.6 (Docker, Debian)

### Воспроизведение ошибки:
* Настроить подключение к БД
* Запустить приложение (скрипты на генерацию сущностей есть)
* Открыть UI
* Попытаться открыть экран "Chair headers", нажав на пункт в меню

**Ожидания:**
* Экран открывается, отображается реестр шапок.

**Действительность:**
* Экран не открывается, при загрузке данных возникает ошибка: PSQLException: ERROR: syntax error at or near ")" Position: 80

### PSQLException
Internal Exception: org.postgresql.util.PSQLException: ERROR: syntax error at or near ")"

Position: 80

Error Code: 0

Call: SELECT ID, DELETED_BY, DELETED_DATE, NAME, ORDER_ FROM DIVISION WHERE ((ID IN ()) AND (0=0))

Query: ReadAllQuery(name="branch" referenceClass=Division sql="SELECT ID, DELETED_BY, DELETED_DATE, NAME, ORDER_ FROM DIVISION WHERE ((ID IN ?) AND (0=0))")
FetchGroup(branch){deletedDate, name, id, deletedBy, order}

### Какое должно быть наполнение сущностей для воспроизведения ошибки:
* Исследование производилось на довольно сложной модели сущностей. Есть вероятность, что ошибку можно воспроизвести на более простом варианте - это не проверялось. Ниже будут описаны основные, на мой взгляд, моменты.
* Нужно несколько связанных сущностей, имеющих ссылочный атрибут одинакового типа (в проекте это ChairHistory и ChairActual, имеют атрибут Division).
* Нужно иметь отношение (1-М) и чтобы в подчиненных сущностях было большое кол-во записей (равное размеру batch eclipselink - 500) (в проекте это ChairHeader и ChairLine. Также ChairLine связана с ChairHistory).
* (Наличие атрибута division у ChairLine не обязательно).
* Необходимо как минимум 2 сущности типа ChairHeader. 
  * Первая из них должна иметь ~500 ChairLine. 
  * Вторая может иметь 1 ChairLine. При этом division у ChairLine.ChairHistory.ChairActual должен быть уникальным. 
  * Также 500-ая ChairLine первого ChairHeader должна быть создана последней среди всех ChairLine (влияет на порядок выборки Postgres-а).

### Что происходит в кейсе воспроизведения ошибки:
#### Предусловия:
* Основными фигурантами будут являться io.jmix.data.impl.EntityFetcher и логика загрузки сущностей eclipselink-а
* Производилась попытка воспроизвести ошибку на hsqldb, которая не увенчалась успехом. Предположительно порядок выгрузки записей зависит от реализации запроса для конкретной БД.
* Загрузка графа объектов происходит в глубину, но с batch-ми eclipselink (500 по дефолту).
* Данные, загруженные batch-ем я называю кэшем запроса. А место, где хранятся уже обработанные созданные сущности - кэшем. Изучены не все нюансы работы кэшем и логики работы загрузки batch. В описании шагов могут быть неточности.

#### Шаги:
1. Пользователь создает запрос на открытие реестра ChairHeader. Происходит построение, инициируется загрузка данных согласно указанному фетч-плану.
2. Подгружаются "примитивные данные" для ChairHeader, запускается "обогащение" для первой из двух сущностей (подгрузка связанных сущностей по идентификаторам).
   1. Подгружаются lines, связанные с обрабатываемым header (их 501, при этом предпоследний - это line из header #2, а последний - это line из header #1. Таким образом обрабатывать header #1 придется двумя batch по 500 записей).
   2. Загруженные lines обогащаются. По очереди для каждой line происходит загрузка и обогащение связанных сущностей по порядку line -> history -> actual.
   3. При первом запросе ChairLine.getHistory() в кэше нет данных, поэтому нужна загрузка. Для оптимизации обрабатываются сразу все записи из текущего batch - собираются все идентификаторы history_id и загружаются все уникальные ChairHistory - примитивные данные для них будут храниться в кэше запроса.
   4. При обогащении header сперва подгружается division (это зависит от порядка атрибутов в фетч-плане). 
      1. При запросе первого division в кэше нет данных, поэтому обрабатываются все записи из кэша запроса - собираются уникальные division_id, они загружаются и их примитивные данные помещаются в кэш запроса.
      2. При этом оказываются загруженными примитивные данные для уникального division, actual и history для line ChairHeader #2. Сейчас они находятся в кэше запроса.
   5. Когда очередь обработки доходит до line #500 из ChairHeader #1 - этой записи не оказывается в кэше запроса, поэтому совершается второй batch-запрос. Теперь в кэше запроса находится только line #500.
   6. Происходит обогащение line #500, при этом перетираются и кэши запросов для history, actual.
3. Процесс обогащения переходит ко второму из ChairHeader.
   1. При загрузке history, и actual оказывается, что они уже лежат в кэше (предполагаю потому что они были обработаны в прошлом batch) (history.division = null). Поэтому нового batch-запроса не производится, в кэше запроса остаются записи для line #500.
   2. В момент, когда вызывается ChairActual.getHistory оказывается, что нужной сущности нет в кэше => необходимо произвести запрос в БД.
      1. Согласно логике eclipselink для загрузки обрабатываются все записи из кэша запроса actual, собираются уникальные division_id, которых еще нет в кэше.
      2. Подходящих записей 0, но этот нюанс не обрабатывается eclipselink и производится подготовленный запрос по идентификаторам, где параметр незаполнен (т.к. идентификаторов - пустое множество).
